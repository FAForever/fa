# /mods/CampaignBranch/ExtractMPBlueprints.lua
#
# Run this script with ExtractMPBlueprints.bat

local unitsdir = '../../Units/'
local datadir = '../../'
local outfile = 'all_units.bp'
local current_id

local all_blueprints = {}
local processed_blueprints = {}

local processFactoriesBuildRate = {
    Categories = { 'FACTORY', },
    UpdateFields = {
        {
            TableName = 'Economy',
            Values = {
                BuildRate = { Mult = 0.5 },
            },
        },
    }
}

local processBuildByFactoryBuildTime = {
    Categories = { 'BUILDBYTIER1FACTORY', 'BUILTBYTIER2FACTORY', 'BUILTBYTIER3FACTORY', 'BUILTBYQUANTUMGATE' },
    UpdateFields = {
        {
            TableName = 'Economy',
            Values = {
                BuildTime = { Mult = 0.5 },
            },
        },
    }
}



dofile(datadir..'../mohodata/lua/system/repr.lua')
dofile(datadir..'../mohodata/lua/system/utils.lua')

local ExtractList = {
    'AI',
    'Economy',
    'Defense',
    'Weapon',
    'Intel',
    'Air',
    'Physics',
}

function ExtractCheck(fieldName)
    for k,v in ExtractList do
        if v == fieldName then
            return true
        end
    end
    return false
end

function ExtractFields(bp, retbp, topLevel)
    retbp = retbp or {}
    
    for k,v in bp do
        # Only extract the proper things
        if topLevel then
        end
        
        if topLevel and not ExtractCheck( k ) then
            continue
        end
        
        if type(v) == 'table' then
            retbp[k] = ExtractFields( v, retbp[k] )
        else
            retbp[k] = v
        end
    end        

    return retbp
end


#===================================================================
# Define constructors that get called from the Blueprint files
#-------------------------------------------------------------------
function Sound()
end

function RPCSound()
end

function UnitBlueprint(bp)
    if bp.BlueprintId then
        current_id = bp.BlueprintId
    else
        bp.BlueprintId = current_id
    end
    
    all_blueprints[current_id] = ExtractFields(bp, all_blueprints[current_id], true)
    
    all_blueprints[current_id].Merge = true # Flag to merge with non-branched blueprint
    all_blueprints[current_id].BlueprintId = current_id
end

function CategoryCheck( bp, categories )
    for _,catCheck in categories do
        for _,catVal in bp.Categories do
            if catVal == catCheck then 
                return true 
            end
        end
    end
    return false
end

function ProcessBlueprint(bp, processData)
    if not processData.Categories or CategoryCheck( bp, processData.Categories ) then
        local outBp = {
            Merge = true,
            BlueprintId = bp.BlueprintId,
        }
        for _,pData in processData.UpdateFields do
            if not outBp[pData.TableName] then
                outBp[pData.TableName] = {}
            end
            for fName,fData in pData.Values do
                outBp[pData.TableName][fName] = ( bp[pData.TableName][fName] + (fData.Add or 0) ) * ( fData.Mult or 1 )
            end
        end
        print('Inserting blueprint intos processed table')
        table.insert( processed_blueprints, outBp )
    end
end


#===================================================================
# Generate the partial blueprint file
#-------------------------------------------------------------------
local specificUnits = {
    'ueb1106', #'uab1106', 'urb1106', 'xsb1106', 
    #'ueb1104', 'uab1104', 'urb1104', 'xsb1104', 
    #'ueb1201', 'uab1201', 'urb1201', 'xsb1201', 
    #'ueb1301', 'uab1301', 'urb1301', 'xsb1301', 
    #'ueb1302', 'uab1302', 'urb1302', 'xsb1302', 
    #'ueb1303', 'uab1303', 'urb1303', 'xsb1303', 
}

function LoadAllBlueprints()
    print( unitsdir .. '*.*' )
    # For all units uncomment
    for i,d in io.dir(unitsdir .. '*.*') do
    
    # To use only those in given table
    # for i,d in specificUnits do
        current_id = string.lower(d)

        local filename = string.format(unitsdir .. '%s/%s_unit.bp', d, d)
        if i == 1 then
            print( filename )
        end
        local ok,msg = pcall(dofile, filename)
        if not ok and not string.find(msg,"cannot read.*: No such file or directory") then
            error(msg)
        end
    end
end

function LoadManualBlueprints()
    print( 'Loading ManualBranched.lua' )
    local ok,msg = pcall(dofile, 'ManualBranched.lua')
end

function ProcessAllBlueprints(processTable)
    for _,bp in all_blueprints do
        ProcessBlueprint( bp, processTable )
    end
end


function WriteBlueprints(bpTable)
    local n = 0
    local file = io.open(outfile, "w")
    file:write("# Generated by ExtractMPBlueprints.lua (", os.date(), " ", os.getenv "USERNAME", ")\n")
    for i,id in table.keys(bpTable) do
        local bp = bpTable[id]
        file:write('UnitBlueprint ', repr(bp), '\n')
        n = n + 1
    end
    file:close()

    print('Wrote '..n..' blueprints to '..outfile)
end


LoadAllBlueprints()
LoadManualBlueprints()
WriteBlueprints(all_blueprints)

# Following for specific processing

#ProcessAllBlueprints(processFactoriesBuildRate)
#ProcessAllBlueprints(processBuildByFactoryBuildTime)

#WriteBlueprints(processed_blueprints)
